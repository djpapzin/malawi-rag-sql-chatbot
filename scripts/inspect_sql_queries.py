#!/usr/bin/env python3
"""
SQL Query Inspector

This script helps inspect the SQL queries generated by LangChain for natural language queries.
It provides a way to see what SQL is being generated for the LLM's responses.
"""

import os
import sys
import json
import sqlite3
import argparse
from pathlib import Path

# Add the project root directory to the Python path
project_root = Path(__file__).parent.parent
sys.path.append(str(project_root))

# Try to import the LangChain SQL integration
try:
    from app.database.langchain_sql import LangChainSQLIntegration
    from app.models import DatabaseManager
    langchain_available = True
except ImportError:
    print("Warning: LangChain SQL integration not available. Only direct SQL queries will work.")
    langchain_available = False

# Display formatting constants
HEADER = '\033[95m'
BLUE = '\033[94m'
GREEN = '\033[92m'
YELLOW = '\033[93m'
RED = '\033[91m'
ENDC = '\033[0m'
BOLD = '\033[1m'

def get_db_connection(db_path=None):
    """Get a connection to the SQLite database."""
    if db_path is None:
        # Default to the database in the project root
        db_path = os.path.join(project_root, 'malawi_projects1.db')
    
    if not os.path.exists(db_path):
        print(f"{RED}Error: Database file not found at: {db_path}{ENDC}")
        sys.exit(1)
    
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row  # Enable row factory for named columns
    return conn

async def process_with_langchain(query, debug=False):
    """Process a natural language query using LangChain SQL integration."""
    if not langchain_available:
        print(f"{RED}Error: LangChain SQL integration not available.{ENDC}")
        return
    
    print(f"\n{BOLD}Natural Language Query:{ENDC} {query}")
    
    try:
        # Initialize LangChain SQL integration
        sql_chain = LangChainSQLIntegration()
        
        # Enable debug mode if requested
        if debug:
            sql_chain.debug_mode = True
        
        # Process the query
        print(f"\n{BOLD}{BLUE}Processing query with LangChain...{ENDC}")
        response = await sql_chain.process_query(query)
        
        # Print the response
        print(f"\n{BOLD}{GREEN}=== LangChain Response ==={ENDC}")
        print(json.dumps(response, indent=2))
        
        # Try to extract the SQL query
        if 'metadata' in response and 'sql_query' in response['metadata']:
            sql_query = response['metadata']['sql_query']
            if sql_query:
                print(f"\n{BOLD}{YELLOW}=== Generated SQL Query ==={ENDC}")
                print(sql_query)
        
    except Exception as e:
        print(f"\n{RED}Error processing query: {str(e)}{ENDC}")

def run_direct_sql(conn, query):
    """Run a direct SQL query against the database."""
    try:
        cursor = conn.cursor()
        cursor.execute(query)
        results = cursor.fetchall()
        
        if not results:
            print(f"\n{YELLOW}Query returned no results.{ENDC}")
            return
        
        # Get column names
        columns = [description[0] for description in cursor.description]
        
        print(f"\n{BOLD}{GREEN}=== SQL Query Results ==={ENDC}")
        print(f"{BOLD}{', '.join(columns)}{ENDC}")
        print("-" * 80)
        
        # Limit to first 20 rows for readability
        max_rows = 20
        row_count = 0
        
        for row in results:
            if row_count >= max_rows:
                print(f"\n{YELLOW}... (showing first {max_rows} of {len(results)} results){ENDC}")
                break
                
            values = [str(row[col]) for col in columns]
            print(", ".join(values))
            row_count += 1
            
    except sqlite3.Error as e:
        print(f"\n{RED}SQL Error: {e}{ENDC}")

async def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(description='Inspect SQL queries generated by LangChain.')
    parser.add_argument('--db', help='Path to the SQLite database file')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode for detailed LangChain output')
    
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # Natural language query command
    nl_parser = subparsers.add_parser('ask', help='Process a natural language query')
    nl_parser.add_argument('question', help='Natural language question to process')
    
    # Direct SQL query command
    sql_parser = subparsers.add_parser('sql', help='Run a direct SQL query')
    sql_parser.add_argument('query', help='SQL query to run')
    
    # Compare command for verifying LLM response accuracy
    compare_parser = subparsers.add_parser('compare', help='Compare LLM response with actual data')
    compare_parser.add_argument('attribute', choices=['count', 'budget'], 
                               help='What to compare (count of projects or budget)')
    compare_parser.add_argument('sector', help='Sector to analyze (e.g., health, education)')
    
    args = parser.parse_args()
    
    # Connect to the database for direct SQL queries
    conn = get_db_connection(args.db)
    
    try:
        if args.command == 'ask' and langchain_available:
            await process_with_langchain(args.question, args.debug)
        elif args.command == 'sql':
            run_direct_sql(conn, args.query)
        elif args.command == 'compare':
            # Get actual data from database
            cursor = conn.cursor()
            query = """
            SELECT COUNT(*) as count, SUM(BUDGET) as total_budget
            FROM proj_dashboard
            WHERE LOWER(PROJECTSECTOR) = LOWER(?)
            """
            cursor.execute(query, (args.sector,))
            result = cursor.fetchone()
            
            count = result['count']
            budget = result['total_budget']
            
            print(f"\n{BOLD}{GREEN}=== Data Verification for {args.sector.title()} Sector ==={ENDC}")
            print(f"Project Count: {count}")
            print(f"Total Budget: MWK {budget:,.2f}")
            
            # Now process with LangChain if available
            if langchain_available:
                if args.attribute == 'count':
                    nl_query = f"How many projects are in the {args.sector} sector?"
                else:
                    nl_query = f"What is the total budget for projects in the {args.sector} sector?"
                
                await process_with_langchain(nl_query, args.debug)
        else:
            print(f"{YELLOW}Please specify a command: ask, sql, or compare{ENDC}")
            parser.print_help()
    finally:
        conn.close()

if __name__ == '__main__':
    import asyncio
    asyncio.run(main()) 